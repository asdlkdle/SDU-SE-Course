### 1.图 = 事物 + 联系（节点+边）

#### 邻接矩阵（相邻节点列表）

#### 关联矩阵（边序列）

#### 路径（简单）、最短路径、距离（最短路径中边的条数），图的直径（任意两个节点的最大***距离***）

#### 图上的广度优先遍历（BFS）

先找当前节点的所有邻居节点，然后再找邻居节点的邻居节点

BFS可以有效地图的的节点”分层“，有利于讨论图的一些性质

#### 图上的深度优先遍历（DFS）

先找到当前节点的邻居节点，然后找邻居节点的一个邻居节点，直到不再有邻居节点

#### 最短路问题算法

##### 1）BFS 不理会目标在哪里，只顾乱走，最后总会到达终点

##### 2）A*算法是对BFS的优化，在其基础上加上了”智能“ 使用了曼哈顿距离

##### 3）DFS 

###### 	（1）暴力法（全排列） 

###### 	（2）Floyd-Warshall（弗洛伊德）算法  

​			可以一次求出所有节点的间的最短距离

​			最简单的最短路算法，比暴力的DFS更简单

​			复杂度很高，仅适用于小规模图（节点<200）

​			动态规划 求i与j间的距离，分为经过其中某个k点和不经过某个k点的路径，取二者中的最短路

##### Bellman-Ford（贝尔曼-福特）算法

单源最短路径问题：给定一个起点s，求它到途中所有n个节点的最短路径

第一轮，给所有n个人每人一次机会，问它的邻居到s的最短距离是多少

更新每人到s的最短距离

特别的，在s的直连邻居中，有个t，得到了到s的最短距离（注意，算法未查找哪个是t）

第二轮重复第一轮操作

更新每人到s的最短距离

特别的，在s和t的直连邻居中，有个v，得到了到s的最短距离（注意，算法未查找哪个是t）

##### SPFA=队列处理+Bellman-Ford

##### Dijkstra（迪克斯特拉）算法 （多米诺骨牌）

单源最短路径问题，高效且稳定，只能处理不含负权边的图

贪心思想+优先队列

#### 连通、连通分量

#### 桥、捷径（AB相连且AB没有共同相邻节点，则为捷径，删除后AB间距离增加2以上）

#### 无向图的连通性

##### 割点、割边（桥）

##### 二分图的最大匹配问题

求包含边数最多的匹配，即二分图的最大匹配

##### 1）最大流法求解二分图匹配

##### 2）匈牙利算法