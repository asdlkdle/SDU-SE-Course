- [第零章](#第零章)
  - [0.1 课程内容](#01-课程内容)
  - [0.2 课程要求](#02-课程要求)
  - [0.3 课程设计](#03-课程设计)
    - [0.3.1 上机时间](#031-上机时间)
    - [0.3.2 选题](#032-选题)
    - [0.3.3 提交](#033-提交)
    - [0.3.4 课设打分](#034-课设打分)
  - [0.4 考试](#04-考试)
- [第一章](#第一章)
  - [1.1 软件工程概（liao）念（tian）](#11-软件工程概liao念tian)
  - [1.2 不同的代表“bug”的名词](#12-不同的代表bug的名词)
  - [1.3 什么是高质量软件](#13-什么是高质量软件)
  - [1.4 软件工程的参与者](#14-软件工程的参与者)
  - [1.5 系统的开发方法](#15-系统的开发方法)
  - [1.6 一种工程化的思路](#16-一种工程化的思路)
  - [1.7 开发人员](#17-开发人员)
  - [1.8 软件工程发生的变化及原因](#18-软件工程发生的变化及原因)
    - [1.8.1 SE实践发生变化的7个关键因素](#181-se实践发生变化的7个关键因素)
    - [1.8.2 软件工程的wasserman规范](#182-软件工程的wasserman规范)
  - [1.9 信息管理实例](#19-信息管理实例)
- [第二章-过程和生命周期的建模](#第二章-过程和生命周期的建模)
  - [2.1 过程的含义](#21-过程的含义)
    - [2.1.1 过程的重要性](#211-过程的重要性)
  - [2.1.2 过程的几个阶段](#212-过程的几个阶段)
  - [2.2 软件过程模型](#22-软件过程模型)
    - [2.2.1 建模的理由](#221-建模的理由)
    - [2.2.2 瀑布模型](#222-瀑布模型)
    - [2.2.3 V模型](#223-v模型)
    - [2.2.4 原型化模型](#224-原型化模型)
    - [2.2.5 可操作性规格说明模型](#225-可操作性规格说明模型)
    - [2.2.6 可转换模型](#226-可转换模型)
    - [2.2.7 阶段化开发-增量和迭代（当下常用）](#227-阶段化开发-增量和迭代当下常用)
    - [2.2.8 螺旋模型](#228-螺旋模型)
    - [2.2.9 敏捷方法](#229-敏捷方法)
  - [2.3 过程建模工具和技术](#23-过程建模工具和技术)
- [第三章-项目管理](#第三章-项目管理)
  - [3.1 项目进展跟踪](#31-项目进展跟踪)
    - [3.1.1 工作分解和活动图](#311-工作分解和活动图)
    - [3.1.2 估算完成时间](#312-估算完成时间)
    - [3.1.3 跟踪进展的工具](#313-跟踪进展的工具)
  - [3.2 项目人员](#32-项目人员)
    - [3.2.1 人员角色和特性](#321-人员角色和特性)
    - [3.2.3 项目组织](#323-项目组织)
  - [3.3 工作量估算](#33-工作量估算)
    - [3.3.1 专家判断法](#331-专家判断法)
    - [3.3.2 算法方法](#332-算法方法)
  - [3.4 风险管理](#34-风险管理)
    - [3.4.2 风险管理活动](#342-风险管理活动)
- [第四章-获取需求](#第四章-获取需求)
  - [4.1 需求的过程](#41-需求的过程)
  - [4.2 需求的引出](#42-需求的引出)
  - [4.3 需求的类型](#43-需求的类型)
    - [4.3.1 需求类型](#431-需求类型)
    - [4.3.2 解决冲突](#432-解决冲突)
    - [4.3.3 需求文档](#433-需求文档)
  - [4.4 需求的特征](#44-需求的特征)
  - [4.5 建模表示法-符号描述](#45-建模表示法-符号描述)
    - [4.5.1 统一建模语言-UML](#451-统一建模语言-uml)
      - [用例图](#用例图)
      - [类图](#类图)
    - [4.5.4 数据流图DFD](#454-数据流图dfd)
  - [4.6 需求和规格说明语言](#46-需求和规格说明语言)
    - [4.6.1 UML](#461-uml)
  - [4.7 原型化需求](#47-原型化需求)
- [第五章-设计体系结构](#第五章-设计体系结构)
  - [5.1 设计过程](#51-设计过程)
  - [5.2 体系结构建模](#52-体系结构建模)
  - [5.3 系统设计中的分解与模块化](#53-系统设计中的分解与模块化)
    - [体系结构视图](#体系结构视图)
  - [5.4 体系结构风格和策略](#54-体系结构风格和策略)
    - [5.4.1 管道与过滤器](#541-管道与过滤器)
    - [5.4.2 面向对象设计](#542-面向对象设计)
    - [5.4.3 隐含调用](#543-隐含调用)
    - [5.4.4 分层设计](#544-分层设计)
  - [EX 设计模式](#ex-设计模式)
    - [简单工厂](#简单工厂)
    - [工厂方法模式](#工厂方法模式)
    - [抽象工厂模式](#抽象工厂模式)
    - [创建者模式（即建造者模式）](#创建者模式即建造者模式)
    - [单例模式](#单例模式)
  - [5.5 设计中的若干问题](#55-设计中的若干问题)
    - [5.5.1 涉及质量的几个概念](#551-涉及质量的几个概念)
    - [5.5.2 模块化与抽象层次](#552-模块化与抽象层次)
    - [5.5.3 设计中的协作关系](#553-设计中的协作关系)
  - [5.6 优秀软件具备的特征（此处为第六章开头）](#56-优秀软件具备的特征此处为第六章开头)
    - [5.6.1 模块独立性](#561-模块独立性)
    - [5.6.2 意外的识别与处理](#562-意外的识别与处理)
    - [5.6.3 防错与容错](#563-防错与容错)
    - [5.6.4 安全性分析（书5.7.3）](#564-安全性分析书573)
    - [5.6.5 成本效益分析（书5.7.5）](#565-成本效益分析书575)
    - [5.6.6 设计评审（书5.9）](#566-设计评审书59)
  - [5.8 设计文档化](#58-设计文档化)
- [第六章-面向对象的思考方法](#第六章-面向对象的思考方法)
  - [6.1 为什么是OO（对应书6.3节）](#61-为什么是oo对应书63节)
    - [6.1.1 什么是OO](#611-什么是oo)
    - [6.1.2 7大OO的特征](#612-7大oo的特征)
  - [6.2 OO开发过程](#62-oo开发过程)
    - [6.2.1 关于OO的几个问题](#621-关于oo的几个问题)
    - [6.2.2 OO需求分析](#622-oo需求分析)
    - [6.2.3 OO设计](#623-oo设计)
    - [6.2.4 OO编码和测试](#624-oo编码和测试)
  - [6.3 使用用例（模型）](#63-使用用例模型)
    - [6.3.1 用例图的组成](#631-用例图的组成)
  - [6.4 UML中体现OO设计](#64-uml中体现oo设计)
    - [6.4.1 介绍UML](#641-介绍uml)
    - [6.4.2 软件过程中的UML使用](#642-软件过程中的uml使用)
  - [6.4+ OO系统设计](#64-oo系统设计)
    - [6.4.1 介绍](#641-介绍)
    - [6.4.2 OO系统设计过程](#642-oo系统设计过程)
  - [EX 面向对象设计原则概述](#ex-面向对象设计原则概述)
  - [6.6 OO程序设计中的其他问题](#66-oo程序设计中的其他问题)
  - [6.7 面向对象度量](#67-面向对象度量)
- [第七章——编写程序](#第七章编写程序)
  - [7.1 编程标准和过程](#71-编程标准和过程)
    - [7.1.1 编程标准的好处](#711-编程标准的好处)
  - [7.2 编程的指导原则](#72-编程的指导原则)
    - [7.2.1 控制结构](#721-控制结构)
    - [7.2.2 算法](#722-算法)
    - [7.2.3 数据结构](#723-数据结构)
    - [7.2.4 其他通用编程策略](#724-其他通用编程策略)
- [第八章——测试程序](#第八章测试程序)
  - [8.1 软件故障和失效](#81-软件故障和失效)
    - [8.1.2 失效](#812-失效)
  - [8.2 有关测试的若干问题](#82-有关测试的若干问题)
    - [8.2.1 测试的组织](#821-测试的组织)
    - [8.2.2 测试的态度](#822-测试的态度)
    - [8.2.3 测试的人员](#823-测试的人员)
    - [8.2.4 测试的观点与方法](#824-测试的观点与方法)
      - [黑盒测试](#黑盒测试)
      - [白盒测试](#白盒测试)
  - [8.3 单元测试](#83-单元测试)
    - [8.3.1 检查代码](#831-检查代码)
    - [8.3.2 测试程序模块](#832-测试程序模块)
      - [程序测试的基本步骤](#程序测试的基本步骤)
      - [测试的彻底性](#测试的彻底性)
  - [8.4 集成测试](#84-集成测试)
    - [8.4.1 由底向上集成测试](#841-由底向上集成测试)
    - [8.4.2 由顶向下集成测试](#842-由顶向下集成测试)
    - [8.4.3 莽撞测试](#843-莽撞测试)
    - [8.4.4 混合方式测试](#844-混合方式测试)
    - [8.4.6 集成测试的具体措施](#846-集成测试的具体措施)
  - [8.5 OO测试](#85-oo测试)
    - [8.5.2 OO测试与传统测试的区别](#852-oo测试与传统测试的区别)
  - [8.6 测试计划](#86-测试计划)
  - [EX 测试用例的设计](#ex-测试用例的设计)
    - [基本测试用例设计](#基本测试用例设计)
      - [一、黑盒测试](#一黑盒测试)
      - [二、白盒测试](#二白盒测试)
      - [三、测试设计策略](#三测试设计策略)
- [第九章-系统测试](#第九章-系统测试)
  - [9.1 系统测试原理](#91-系统测试原理)
    - [9.1.1 软件缺陷的来源](#911-软件缺陷的来源)
    - [9.1.2 系统测试过程](#912-系统测试过程)
    - [9.1.3 配置管理](#913-配置管理)
  - [9.2 功能测试](#92-功能测试)
    - [9.2.1 目的和作用](#921-目的和作用)
    - [9.2.2 因果图](#922-因果图)
  - [9.3 性能测试](#93-性能测试)
    - [9.3.2 性能测试形式](#932-性能测试形式)
  - [9.5 验收测试](#95-验收测试)
  - [9.6 安装测试](#96-安装测试)
- [final-考试](#final-考试)
  - [复习文档基础](#复习文档基础)
  - [试卷基础](#试卷基础)
# 第零章
***会有期末复习***
史清华（这老师有意思）

本人使用的书是：
软件工程（第4版·修订版）
原作者：Shari Lawrence Pfleeger(美)，Joanne M. Atlee(加)
译者：杨卫东
人民邮电出版社
ISBN 978-7-115-49807-6
## 0.1 课程内容
项目管理 技术研发 软件工程学
- part1：1~3章
- part2：4~11章
- part3：12~14章
在讲完第九章后就考核（？）
## 0.2 课程要求
- 底线：初步了解软件工程的实操流程和复杂工程问题的大致求解
- 有课程设计？？？
## 0.3 课程设计
### 0.3.1 上机时间
上机时间：第三周——第十周，实验楼303，每周一16——18点
### 0.3.2 选题
核心任务是完成软件工程中某一个过程的文档
有多个方向可选：
- 软件工程全过程
- 需求分析
- 系统设计
- 编码及测试
- 测试（这个题目要求是比较正规的测试过程，要能发现系统中的各个问题）
### 0.3.3 提交
不支持但也不反对提交源码
可以利用以前的项目
允许多人合作，但是要说明具体工作和提交内容
向上考虑，也可以考虑开发费用等等
项目组长要负责，项目不成功组长全责
### 0.3.4 课设打分
原则是：拿来捞考试，考试全班砸了就适当提高，考试好久严一些（好耶！）
课设优秀比例：上学期是17~18个左右90分以上
## 0.4 考试

# 第一章
## 1.1 软件工程概（liao）念（tian）
软件工程师要做到：采用高质量软件环境及工具，使软件能够按照某种能够反映软件开发规律的***规范/模式***来开发
## 1.2 不同的代表“bug”的名词
- **error**(错误):人们在软件开发过程中出现的错误(如错误理解了需求，错误的代码)
- **fault**(故障):因为“error”而存在于软件中的缺陷，这可能是错误的代码或用户手册中错误的描述
- **failure**(失效):运行时，**系统**由于“fault”而产生的问题

**审查**可以有效找出这些bug
## 1.3 什么是高质量软件
IEEE给出的高质量软件标准的答案:
- 最终产品质量
用户注重易学易用性，开发者注重软件的内部特征
- 生产过程质量
注重过程的建模
CMM和CMMI是代表
- 商业价值
技术价值和商业价值是有区别的，商业价值侧重市场
## 1.4 软件工程的参与者
- 客户
- 开发者
- 使用者

结论：软件工程是系统工程……[TODO]
## 1.5 系统的开发方法
一个项目的**边界**是很重要的
软件 = 对象+活动+关系+系统边界
- 对象:这里的对象是不精确的，在开发初期它可能只是属性聚合而成的实体，而不是OOP中经过各种拆分和聚合后形成的精确对象
- 关系:对实体和活动中数据项及动作的相互关系的描述
- 边界:清晰的边界可以将项目划分为各个小的部分，以便于将工作分配下去同步开展
## 1.6 一种工程化的思路
软件开发的过程包括：
- **需求分析与定义**
  进行问题定义、可行性分析
  得出软件需求说明书SRS
  定义需求，这涉及边界、实体、活动
- **系统设计**
  设计用户界面、系统设计文档SAD(software architecture diagrams)，处于设计外观和功能的上层阶段，并得到设计文档
- **程序设计**
  涉及模块功能的算法与数据的描述，不会具体到某种语言，停留在伪代码阶段
- **程序实现(敲代码)**
  编程和debug，除了源代码外还要得到注释、文档
- **单元测试**
  模块的功能与性能的测试，根据*设计文档*得到测试报告
- **集成测试**
  根据系统架构图进行测试，这个过程中是模块的不断组装，而不是一蹴而就
  在这个过程中，即使各个模块测试是正常的，在模块集成的过程中也可能会出现问题(在集成时数据传输不匹配，或性能不过关)
- **系统测试**
  面向软件需求说明书进行测试，要看系统能否满足需求
- **系统交付**
  交付
- **维护**
  修改软件的过程，不断进行改错和满足新需求
## 1.7 开发人员
![avatar](/images/1.7-1.JPG)
- **软件架构师**
  属于高级程序员，侧重开发过程和模式的论证
## 1.8 软件工程发生的变化及原因
### 1.8.1 SE实践发生变化的7个关键因素
- 商业软件投入市场实践的紧迫性
- 计算经济学的改变：更低的硬件成本，更高的开发、维护成本
- 强大的桌面平台计算的可用性
- 广泛的局域网和广域网
- 面向对象技术的出现和应用
- 图形界面的使用
- 软件开发瀑布模型的不可预测性

### 1.8.2 软件工程的wasserman规范
- 抽象：基于某种层次的概念化描述
- 分析、设计方法和符号描述系统
- 用户界面原型化：构建一个系统的小版本，用来帮助用户标识需求和证明设计与方法的可行性
- 软件体系结构：根据一组结构单元间的相互关系描述系统
- 软件过程：各种组织及规范方法，对于不同的软件其开发过程难以以一个范式进行预先统一
- 复用：利用程序之间的共性部件进行各种复用
- 测度：量化描述成果与目标
- 开发工具与集成环境
## 1.9 信息管理实例
边界很重要，在项目中，顶层设计与规划是重中之重
# 第二章-过程和生命周期的建模
## 2.1 过程的含义
- 过程：软件开发活动中产生某种期望结果的一些列有序任务，涉及活动、约束和资源。它可以被分解为系列动作。
### 2.1.1 过程的重要性
- 通用性
- 自我指导性
## 2.1.2 过程的几个阶段
## 2.2 软件过程模型
### 2.2.1 建模的理由
- 达成共识，共识即模型
- 发现过程层面的缺陷，让过程更有效
- 模型应反映开发的目标，评价候选的活动的有效性和正确性
- 相时而动，指定应对特定情况的定制过程
参见第一章
### 2.2.2 瀑布模型
![avatar](/images/2.2-1.JPG)
缺点：
- ！软件开发的各个阶段的转换时混乱的，瀑布模型在软件变动时无法处理实际过程中的重复开发问题
改良：
- 原型化
![avatar](/images/2.2-2.JPG)
### 2.2.3 V模型
![avatar](/images/2.2-3.JPG)
### 2.2.4 原型化模型
![avatar](/images/2.2-4.JPG)
对于各个需求，遵循不断地建立原型、测试原型、改进原型的过程，使得原型最终成为合格的系统
### 2.2.5 可操作性规格说明模型
### 2.2.6 可转换模型
### 2.2.7 阶段化开发-增量和迭代（当下常用）
- 阶段性的交付系统，其余部分还在开发时，用户就已经能获得一部分功能。用户使用版本1时，开发者往往正在开发下一个版本2
![avatar](/images/2.2-5.JPG)
- 阶段化开发也分为两种
  - 增量化开发是通过不断开发新的部分来完成开发
  - 迭代开发是在一开始就有完整的系统框架，通过对系统整体的不断迭代完善进行开发
### 2.2.8 螺旋模型
额自行感受吧
![avatar](/images/2.2-6.JPG)
沿着螺旋由内向外不断迭代，引入了一个“操作概念”文档，是从高层描述系统如何工作的文档。操作概念是面向现实的描述。
每一层迭代都要评估预算、可选方案、约束、风险分析等因素
- 第一次迭代产生操作概念
- 第二次迭代产生需求
- 第三次迭代产生设计
- 第四次迭代产生成品
### 2.2.9 敏捷方法
反重量级的方法原则，原则上是通过尽可能早、持续地交付有价值的软件来使客户满意
四原则：
- 人与交互胜于过程和工具
- 做软件而非写文档
- 客户合作胜于合同谈判
- 相应变化胜于遵循计划

敏捷方法只是一个原则性的思路，有很多方法都属于敏捷方法的一员
非常多，建议看书（P42）
## 2.3 过程建模工具和技术
。。。
# 第三章-项目管理
本章的核心是预测工作量和完成时间，我们作为一个Manager，要尽力掌握整个项目的全部实施过程，关注各个地方的问题，统领全局
## 3.1 项目进展跟踪
- 项目进度是对特定项目的软件开发周期的刻画。包括对项目阶段、步骤、活动的分解，对各个离散的活动的交互关系的描述，以及对各个活动完成时间及整个项目完成时间的初步估算
  - 先确定提交物
  - 再确定必要的活动
  - 最后确定“里程碑”——即某些特定的时刻
### 3.1.1 工作分解和活动图
通过之前的，对于提交物、活动、里程碑的确定，我们可以将项目分解为若干离散部分的结合，这就为项目生成了一个**工作分解结构**。使用**活动图**可以描述它
但是要明确的是：**边代表活动，它应当由两个里程碑表示**，比如从A里程碑到B里程碑的活动应当表示为AB。
![avatar](/images/3.1-1.JPG)
### 3.1.2 估算完成时间
- 真实时间/实际时间：估算完成某个活动的必需的时间量
- 可用时间：完成某个活动的可用的时间量
- 时差：最晚开始时间 - 最早开始时间
  这里的最晚开始时间指的是：不同的活动由于处于不同的行动分支，它们最早可以开始的时间并不一样，所需的执行时间也不一样，而比较早可以开始或者执行时间很短的活动并没有立刻开始的必要，它即使“等一会”较慢开始或时间较长的活动也可以最终与其一起完成
- 计算关键路径
  要注意：活动是边，点是里程碑
  - step1：确定每个活动的最早开始时间
    一个活动的开始的前提是完成他的前置里程碑的所有活动结束。简单来说就是一个活动的最早开始时间是到达它的开始节点的所有路径中最长的一个。
    在这一步，我们完全可以获得所有活动的最早开始时间。
  - step2：确定每个活动的最晚开始时间
    一个活动的最晚开始时间，取决于其达到的里程碑为起点的所有活动中，最小的最晚开始时间（因为最晚开始时间是不影响项目最快完成的“底线”，那么我们就要向着最早的最晚开始时间看起）。
    而对于“结束”这一里程碑，如果要按照这里的说法解决问题的话，我们可以认为：这个里程碑的“最小的最晚开始时间”就是项目结束的时间，也就是所有通往结束的路径中最长的那一条到达结束的时间。
    比如：如果有A、B、C三个活动指向结束，到达阶数的时间分别为20、18、16，那么项目结束时间就是20，A、B、C都只需要在20时到达结束就可以，用20减去它们的活动耗时就行了。
    我们假设C耗时5，那C的最晚开始时间就是15。再假设D、E指向作为C的开始的里程碑，那么它们都只需要在15到达这个里程碑就可以，拿15减活动耗时即可
  - step3：计算时差
    时间 = 最晚开始时间 - 最早开始时间
### 3.1.3 跟踪进展的工具
**甘特图**
## 3.2 项目人员
### 3.2.1 人员角色和特性
关键的项目活动
- 需求分析
- 系统设计
- 程序设计
- 程序实现
- 测试
- 培训
- 维护
- 质量保证

### 3.2.3 项目组织
- 主程序员负责制小组：一个人负责总体开发，其余人都向它汇报，并且他有最终决策权
- 忘我方法：每个人平等的担负责任，投票产生决策
适用情况
- 当人员多，项目稳定性高时，适宜采用结构化强的团队
- 当项目有大量不确定因素，需要突破、创新时，适宜采用结构化弱的团队

## 3.3 工作量估算
- 设施成本
- 项目成本
- 工作量
### 3.3.1 专家判断法
### 3.3.2 算法方法
唔。。。额这部分跟个鬼一样，看书得了
## 3.4 风险管理
- 风险：在软件生产过程中不希望看到的、有负面结果的事
### 3.4.2 风险管理活动
![](images\2022-03-14-14-36-19.png)
- 产品过大：从小型内核开始
- 过难或复杂的功能：开始时就简化或替代掉这些功能
……………………
# 第四章-获取需求
- 需求：是对来自用户的关于软件系统额期望行为的综合描述，涉及系统的对象、状态、约束、功能等
- 我们的任务是：理解用户的问题和需求，用较为规范的语言来描述它
- 需求分析过程中，只考虑客户的问题，不应该去考虑解决方案和实施
## 4.1 需求的过程
![](images\2022-03-14-15-16-53.png)
- 原始需求获取（引发）：从客户处获取
- 问题分析（分析）：可以在模型、原型中寻获需求
- 规格说明草稿（规格说明）
- 需求核准（确认）
## 4.2 需求的引出
即确定用户想要什么
但由于开发者和客户的背景、视角、利益不一样，所以会有冲突与不一致
- 分析师应该有能力理解各方观点，并使多方达成共识
- 需求分析一般步骤
称用户目前使用的系统为“当前系统”，应用计算机以后的系统称为“目标系统”
  1. ？
  2. 去掉具体模型中的非本质因素，抽象出当前系统的逻辑模型。
  3. 分析当前系统与目标系统的差别，建立目标系统的逻辑模型。
  4. 对目标系统进行完善和补充，并写出完整的需求说明。
  5. 数据流图DFD形式表示系统

## 4.3 需求的类型
### 4.3.1 需求类型
- 功能需求：描述系统内部功能或系统与外部的交互作用
- 质量需求：描述一些质量特性，比如响应时间的要求

- 设计约束
- 过程约束
![](images\2022-03-21-14-45-03.png)
### 4.3.2 解决冲突
- 需求优先级
  - 必需的：即绝对要满足的要求
  - 值得的：即非常值得去做但并非必需的要求
  - 可选的：即可要可不要的要求
### 4.3.3 需求文档
有两种：
- 需求定义：客户想要的每一件事的完整列表。这个需求是直观的，用户描述的，可能以各种形式描述的。有时，需求的描述可能与我们的系统没有直接联系，不能直接指导系统的开发。
- 需求规格说明：将需求重新陈述为关于要构建的系统将如何运转的规格说明。需求规格说明只专注于**系统和需求重叠的部分**，而不考虑那些与需求相关，但我们的系统不会触及的部分。
  - 例如：
  我们要开发一个动物园旋转门，要求未付费的人不能进入动物园，付费的人可以进入动物园，但“进入动物园”的概念和“旋转门”是无关的，所以我们要重新描述需求，让这个需求与我们的系统直接相关，比如将“不能进入动物园”转化为“旋转门禁止开放”。
## 4.4 需求的特征
- 正确性
- 一致性
- 无二义性
- 完备性
- 可行性
- 与实际需求是否相关
- 可测试性
## 4.5 建模表示法-符号描述
- 面向对象建模：对实体进行抽象
### 4.5.1 统一建模语言-UML
5类10种
- 用例图
- 静态图（类图，对象图，包图）
- 行为图（状态图，活动图）
- 交互图（顺序图，合作图）
- 实现图（构件图，配置图）

即使是小型团队，最少也会用到：用例图、类图、活动图
#### 用例图
一个用例是用户（或角色）与计算机之间为了达到某个目的进行的一次典型交互作用，在图中就以椭圆代表
*注意：用例只和参与者打交道，不能将功能分解成大量用例
![](images\2022-03-21-15-38-46.png)
每一个用例都应该有一个用例规约，关键属性是事件流，代表这个用例应该完成什么
![](images\2022-03-21-15-39-46.png)
用例除了直接的需求，还要表示出潜在的需求
具体的图例直接上ppt原图，符号并不拘泥于展示的这些，还可以自定义符号
![](images\2022-03-21-15-44-46.png)
![](images\2022-03-21-15-45-11.png)
（OCL是对象约束语言，用途是用来说明在图形化的系统模型中不能充分表达的建模信息，是一种形式化语言。）
#### 类图
描述系统中各种类以及之间的关系

### 4.5.4 数据流图DFD

## 4.6 需求和规格说明语言
### 4.6.1 UML
在4.5.1中就说过，这里再来一次
5类10种
- 用例图
- 静态图（类图（一种ER图），对象图，包图）
- 行为图（状态图，活动图）
- 交互图（顺序图，合作图）
- 实现图（构件图，配置图）

## 4.7 原型化需求
- 用户不能严格确定自己完整的需求
- 用户有确定的需求，但是开发者无法肯定方案的可行性

原型化可以帮助获取需求的细节
- 抛弃式原型：用完即扔，只用于了解问题
- 进化式原型：将来会作为提交的系统的一部分

# 第五章-设计体系结构
这是需求分析后的步骤，说明软件系统如何构造
## 5.1 设计过程
- 初始建模：根据需求描述的系统关键特性确定软件体系结构的风格
- 分析
- 文档化
- 复审
- 正式SAD（软件体系结构图）

## 5.2 体系结构建模

## 5.3 系统设计中的分解与模块化
- 功能性分解：将功能或需求分解为模块，并不断分解
- 面向特征的设计：功能性分解的一种，它的高层设计描述的是某个服务和特征集的系统，低层描述各个特征如何扩展服务
- 面向数据的分解：关注如何将数据分解为模块
- 面向进程的分解：将系统分解为一系列并发进程
- 面向事件的分解：将各个事件的责任分配给不同的模块
- 面向对象的设计：将对象分配给模块。高层设计中定义系统对象的类型并解释对象间如何管理，低层细化对象属性和操作

### 体系结构视图
大部分可以用UML描述
## 5.4 体系结构风格和策略
### 5.4.1 管道与过滤器

### 5.4.2 面向对象设计
- OOA：面向对象分析方法
- OOD：面向对象设计
- OOP：面向对象程序设计
### 5.4.3 隐含调用
### 5.4.4 分层设计

## EX 设计模式
啊~哈！
- 设计模式：一套反复使用的的代码设计经验

本章内容大多可以参见我的另一个笔记——设计模式，这里只写一些课上提到的额外的点
### 简单工厂
### 工厂方法模式
### 抽象工厂模式
当需要修改使用的对象时，可以只在后端的工厂类修改，不动客户端
### 创建者模式（即建造者模式）

### 单例模式
## 5.5 设计中的若干问题
### 5.5.1 涉及质量的几个概念
- 可修改性：修改系统的难易程度，要求高内聚、低耦合
- 可维护性
- 性能
- 安全性
- 可靠性
- 健壮性
- 易用性
### 5.5.2 模块化与抽象层次
- 抽象：对细节的隐藏

### 5.5.3 设计中的协作关系

## 5.6 优秀软件具备的特征（此处为第六章开头）
### 5.6.1 模块独立性
高内聚、低耦合
- 耦合的6个等级（由低到高）：
  - 非直接耦合：模块间没有信息传递
  - 数据耦合：模块间传递的是数据
  - 特征耦合：模块间传递的是数据结构
  - 控制耦合：模块间传递的是控制量
  - 公共耦合：不同模块访问公共数据
  - 内容耦合：一个模块直接修改另一个模块的内容
- 内聚的7个等级：
  - 偶然性内聚：不相关的方法或数据出现在同一模块中
  - 逻辑性内聚：逻辑上相关的方法或数据出现在同一模块中
  - 时间性内聚：要求在同一时间完成的各部分出现在同一模块中
  - 过程性内聚：有前后次序的各部分出现在同一模块中
  - 通讯性内聚：共享信息的各部分出现在同一模块中
  - 顺序性内聚：有输入输出关系的各部分出现在同一模块中
  - 功能性内聚：组成单一功能的各部分出现在同一模块中
### 5.6.2 意外的识别与处理
### 5.6.3 防错与容错
### 5.6.4 安全性分析（书5.7.3）
### 5.6.5 成本效益分析（书5.7.5）
### 5.6.6 设计评审（书5.9）

## 5.8 设计文档化


# 第六章-面向对象的思考方法
## 6.1 为什么是OO（对应书6.3节）
### 6.1.1 什么是OO
OO即面向对象，是一种软件开发方法，它将问题及其解决方法组织成一系列独立的对象，数据结构和动作都被包括在内。
### 6.1.2 7大OO的特征
- 标识：对象的命名应当把自己和其他对象从语义上区分开来
- 抽象
- 分类：对实体的功能进行区分，最终形成类
- 封装
- 继承
- 多态
- 持久性：借助外部存储，使对象信息持久化存储

## 6.2 OO开发过程
### 6.2.1 关于OO的几个问题
- OO过程的定义：OO需求+OO高层设计+OO底层设计+OO程序设计+OO测试
### 6.2.2 OO需求分析
- 对象模型
- 类层次结构图/素描式类图
### 6.2.3 OO设计
- 定义模块级别的系统构成
- 定义类
- 定义对象和类之间的交互
### 6.2.4 OO编码和测试
- OO编码：将模型转化为面向对象的语法
- OO测试：包括单元测试、集成测试、系统测试、验收测试

## 6.3 使用用例（模型）
### 6.3.1 用例图的组成
- 用例：描述系统对外提供的功能
- 执行者/角色：与系统交互的实体
- 包含关系：可以指向被提取出的公共行为
- 扩展关系：向某一个更深的特殊情况扩展出用例的关系
## 6.4 UML中体现OO设计
### 6.4.1 介绍UML

### 6.4.2 软件过程中的UML使用
- 需求过程

- 设计过程
  - step1：类图、对象图
  - step2：活动图、状态图
  - step3：顺序图、协作图（前者注重时间、协作关系是隐藏的）

## 6.4+ OO系统设计
### 6.4.1 介绍
- OO设计从类图开始

### 6.4.2 OO系统设计过程
1. 初版类图
- 确定类和属性
  - 在确定类时，可以根据一些预先抽象好的概念进行对应：
     ![](images\2022-04-11-14-21-51.png)
  - 其余的一些窍门：
     ![](images\2022-04-11-14-22-45.png)
- 确定行为
- UML类图绘制
  - 类间关系
    - 继承extends
      ***箭头指向父类***
      ![](images\2022-04-11-14-27-29.png)
    - 关联association
      ![](images\2022-04-11-14-30-03.png)
      ***箭头指向被依赖者***
      可以使用双向箭头表示双向关联
      一个类依赖另一个类可以认为是关联，比如属性中引用了另一个类
      还可以指明关联中双方的数量，比如一方会引用多个另一方：
      ![](images\2022-04-11-14-36-26.png)
    - 聚合Aggregation
      ***箭头指向部分，菱形指向整体***
      表示一个事物的整体和部分，而且这个“部分”不在整体中也有意义，两者可以彼此独立存在
      ![](images\2022-04-11-14-41-28.png)
    - 组合Composition
      ***箭头指向部分，实心菱形指向整体***
      表示一个事务的整体和部分，这个“部分”的生命周期受“整体”影响，“整体”不存在时“部分”也就不复存在
      ![](images\2022-04-11-14-44-44.png)
    - 依赖Dependency
      ***箭头指向被依赖方***
      一个类的实现依赖于另一个类的关系，往往体现为一个类的方法的参数是另一个类
## EX 面向对象设计原则概述
啊~哈！
## 6.6 OO程序设计中的其他问题
- 在程序设计中会遇到非功能性的需求，如数据结构、运行管理细节等，更贴近编程技术，并由此产生许多并不是反映现实实体的对象，如链表
## 6.7 面向对象度量

# 第七章——编写程序
## 7.1 编程标准和过程
### 7.1.1 编程标准的好处
- 编程标准对自身的用处
  - 易于组织思路、避免错误
  - 易于利用文档追踪进度
  - 便于将设计转化为代码
- 编程标准对他人的用处
  - 易于维护
  - 易于测试
  - 易于复用
## 7.2 编程的指导原则
### 7.2.1 控制结构
- 适当重组代码使代码易懂
- 模块化可以使代码易于理解
- 应当让结构具有通用性
- 耦合和依赖关系必须可见（能从注释、变量名等处读出来）

### 7.2.2 算法
编写一个更快运行的代码往往有代价
- 编写速度会更慢
- 测试代码的时间更长
- 用户更难理解
- 修改代码更耗时

### 7.2.3 数据结构
- 简化程序
- 从数据结构出发，决定程序结构

### 7.2.4 其他通用编程策略
- 局部化输出
- 设计时包含伪代码
- 改成、重写而不是打补丁
- 重用

# 第八章——测试程序
## 8.1 软件故障和失效

### 8.1.2 失效
软件动作与需求不符称为失效

## 8.2 有关测试的若干问题
### 8.2.1 测试的组织
- 几个阶段
  - 单元测试：确认各部分的功能
  - 集成测试：确认各部分集成后的功能
  - 功能测试：根据SRS验收功能
  - 性能测试
  - 验收测试：
  - 安装测试：在实际环境中进行测试
### 8.2.2 测试的态度

### 8.2.3 测试的人员
使用独立测试团队

### 8.2.4 测试的观点与方法
#### 黑盒测试
测试人员在**完全不了解程序内部的逻辑结构和内部特性**的情况下，只依据程序的需求规格及设计说明，检查程序的功能是否符合它的功能说明
- 优点：测试人员不受程序所带来的束缚，测试更具有客观性
- 缺点：有时会无法进行完备的测试，在不知道程序内部逻辑的情况下，设计测试时就可能无法面面俱到

#### 白盒测试
测试人员拥有全套文档，以**程序内部结构为基本依据**，手动或自动进行测试
- 优点：有助于进行更细致、切中要害的测试
- 缺点：极度细致的测试不现实

## 8.3 单元测试
步骤：
- 静态地检查代码
- 编译，debug
- 设计测试用例并测试

### 8.3.1 检查代码
- 代码复审：对照文档检查代码，看看有没有对需求的曲解

### 8.3.2 测试程序模块
- 测试用例：以测试程序为目的输入的数据以及对应期望的结果
#### 程序测试的基本步骤
  - 确定测试目标和计划
  - 确定测试用例
    - 黑盒：等价分类法（等）
      ![](images\2022-04-25-15-25-55.png)
    - 白盒：各种覆盖方法（等）
  - 执行测试
#### 测试的彻底性
- 语句（覆盖）测试：保证模块中每个语句至少执行一遍
- 分支测试：保证每个判定点的每个分支至少选择到一次
- 路径模式：不同的路径中都被至少执行一次

一般，以上三者使用的用例从少到多
## 8.4 集成测试
### 8.4.1 由底向上集成测试
- 从最底层开始，由下而上按调用关系逐步添加新模块，组成子系统分别测试，直到全部模块组装完毕
- 优点：每一次测试的都是真实模块，测试用例好写
- 缺点：高层部分的缺陷不容易被解决

### 8.4.2 由顶向下集成测试
- 从顶层控制组件开始进行测试，然后逐步将调用的下级组件组合起来，再对更大的子系统测试
- 优点：主要的顶层问题会在早期发现
- 缺点：不好设计用例
  
### 8.4.3 莽撞测试
- 直接继承所有模块进行测试
- 缺点：系统庞大时极度不利
### 8.4.4 混合方式测试
- 将系统分为上中下三层，上层用由顶向下，下层用由底向上，中层独立测试

### 8.4.6 集成测试的具体措施
- 深度优先策略
- 广度优先策略

## 8.5 OO测试
### 8.5.2 OO测试与传统测试的区别
- 以继承的方式添加新子类时，需要重新测试所有方法，而不只是测试新方法
- OO测试的单元测试容易，集成测试复杂
- OO测试面临的困难
  ![](images\2022-04-27-09-22-53.png)

## 8.6 测试计划

## EX 测试用例的设计
**完全测试是不可能的**
**不完全测试是有风险的**
- 软件测试的寄生虫现象：发现的缺陷越多，越代表其背后可能有更多缺陷（人总会犯同类的错误）
- 软件测试的杀虫剂现像：测试的越多，剩下的缺陷越不容易被发现
- 软件测试的不修复原则：并非所有缺陷都能修复，有些缺陷修复难、耗时、风险大

### 基本测试用例设计
#### 一、黑盒测试
1. 等价分类法
   将输入域划分为若干等价类，并且从每个等价类里选择有代表性的少量用例代表其余所有情况。其根本逻辑在于：如果这些代表性用例没有出现问题，那么其他的也没有问题
   - 有效等价类
   - 无效等价类
   对有效等价类的用例，尽量用一个用例覆盖尽可能多的等价类；对无效等价类，必须为每一个无效等价类都设计一个用例
#### 二、白盒测试
选取合适的用例，对系统的源代码实现充分的覆盖
1. 逻辑覆盖法
   一组逻辑覆盖方法的统称。按对程序逻辑覆盖程度的由低到高，分为：
   - 语句覆盖：每条语句至少执行一次
   - 判定覆盖：每一分支至少执行一次，又称分支覆盖
   - 条件覆盖：每个条件均按“真”和“假”两种结果至少执行一次
   - *条件组合覆盖：某个分支的虽然只有一种结果，但可能由多个条件组合而成。条件覆盖只要求单个条件一次真一次假即可，条件组合覆盖要求覆盖所有组合，即使有些组合最终结果一样。
2. 路径覆盖法
   对流程图来说，结点覆盖意味着要经过所有结点，边覆盖意味着覆盖所有边，两者都满足就是路径覆盖法，也即穷尽所有路径。
   路径覆盖法与穷举测试有所不同，路径覆盖法并不关注循环次数，某个循环语句循环1次和n次对于路径覆盖法是一样的，但是穷举测试则认为它们是不同的。

#### 三、测试设计策略
除了很小的程序外，集成测试及之后的测试阶段都采用黑盒（白盒在规模较大的系统中表现不佳，过于复杂）
单元测试设计策略有所不同，可以考虑黑盒白盒结合，更加自由

# 第九章-系统测试
单元测试和集成测试可以由一小部分人完成，系统测试需要整个开发团队参与
## 9.1 系统测试原理
- 在这一步，程序员和测试这样要满足设计师的要求
- 要满足客户的需求，客户得点头
### 9.1.1 软件缺陷的来源
- 来源于各个阶段
- 需求的缺陷
- 系统设计的缺陷

### 9.1.2 系统测试过程
- 功能测试
- 性能测试
- 验收测试：在这一步，需要开始涉及用户的需求，而不光是SRS
- 安装测试

？[todo]
### 9.1.3 配置管理

## 9.2 功能测试
### 9.2.1 目的和作用
- 根据SRS测试功能需求
### 9.2.2 因果图
[todo]

## 9.3 性能测试
### 9.3.2 性能测试形式
- 压力测试
- 容量测试

## 9.5 验收测试

## 9.6 安装测试


# final-考试
平时分30分
## 复习文档基础
- 注释掉为非重点，**必不考（答疑补充）**
- “了解”代表只会出选择、判断类的小题
- “熟悉”“掌握”代表这是重点

## 试卷基础
- 中文答题
- 课件为主、教材为辅

- 名词解释（每题2分）
- 判断题（每题1分）
- 选择题（单选，每题1分，20题）
- 简述题（每题6分，总分30分左右）
- 综合应用（总分20分）

- 判断、选择有些考理解，不是严格在划定范围内
